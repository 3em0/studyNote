# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

channel.nio.interrupted=Le thread en cours a \u00e9t\u00e9 interrompu
channel.nio.ssl.appInputNotEmpty=Le tampon d'entr\u00e9e de l'application contient toujours des donn\u00e9es, des donn\u00e9es ont \u00e9t\u00e9 perdues
channel.nio.ssl.appOutputNotEmpty=Le tampon de sortie de l'application contient toujours des donn\u00e9es, des donn\u00e9es ont \u00e9t\u00e9 perdues
channel.nio.ssl.closeSilentError=Il y a eu une exception en essayant de fermer proprement la connection, comme pr\u00e9vu
channel.nio.ssl.closing=Le canal est en \u00e9tat de fermeture
channel.nio.ssl.eofDuringHandshake=EOF pendant la n\u00e9gociation
channel.nio.ssl.expandNetInBuffer=Augmentation de la taille du tampon d''entr\u00e9e r\u00e9seau \u00e0 [{0}] octets
channel.nio.ssl.expandNetOutBuffer=Augmentation de la taille du tampon de sortie r\u00e9seau \u00e0 [{0}] octets
channel.nio.ssl.foundHttp=Une requ\u00eate HTTP non crypt\u00e9e a \u00e9t\u00e9 trouv\u00e9e sur la connection qui aurait d\u00fb \u00eatre crypt\u00e9e par TLS
channel.nio.ssl.handshakeError=Erreur lors de la n\u00e9gociation
channel.nio.ssl.incompleteHandshake=La n\u00e9gociation est incompl\u00e8te, elle doit \u00eatre termin\u00e9e pour pouvoir lire des donn\u00e9es
channel.nio.ssl.invalidCloseState=Etat de fermeture invalide, aucune donn\u00e9e ne sera envoy\u00e9e sur le r\u00e9seau
channel.nio.ssl.invalidStatus=Etat inattendu [{0}]
channel.nio.ssl.netInputNotEmpty=Le tampon d'entr\u00e9e du r\u00e9seau contient toujours des donn\u00e9es, la n\u00e9gociation va \u00e9chouer
channel.nio.ssl.netOutputNotEmpty=Le tampon de sortie du r\u00e9seau contient toujours des donn\u00e9es, la n\u00e9gociation va \u00e9chouer
channel.nio.ssl.notHandshaking=NOT_HANDSHAKING pendant la n\u00e9gociation SSL
channel.nio.ssl.pendingWriteDuringClose=Une \u00e9criture est en cours donc des donn\u00e9es sont toujours pr\u00e9sentes dans le tampon r\u00e9seau, impossible d'envoyer le message de fermeture de SSL mais le socket sera ferm\u00e9 de toutes mani\u00e8res
channel.nio.ssl.remainingDataDuringClose=Des donn\u00e9es sont toujours pr\u00e9sentes dans le tampon r\u00e9seau, impossible d'envoyer le message de fermeture de SSL mais le socket sera ferm\u00e9 de toutes mani\u00e8res
channel.nio.ssl.sniDefault=Incapacit\u00e9 d'accumuler assez d'information pour d\u00e9terminer le nom du h\u00f4te SNI demand\u00e9.  Valeur par d\u00e9faut utilis\u00e9e.
channel.nio.ssl.sniHostName=Le nom d''h\u00f4te SNI extrait pour la connexion [{0}] est [{1}]
channel.nio.ssl.timeoutDuringHandshake=Timeout pendant la n\u00e9gociation
channel.nio.ssl.unexpectedStatusDuringUnwrap=Statut inattendu [{0}] lors de l''UNWRAP de la n\u00e9gociation
channel.nio.ssl.unexpectedStatusDuringWrap=Statut inattendu [{0}] lors du WRAP de la n\u00e9gociation
channel.nio.ssl.unwrapFail=Incapable de d\u00e9senrober les donn\u00e9es ("unwrap data"), statut invalide [{0}]
channel.nio.ssl.unwrapFailResize=Impossible de faire l''unwrap des donn\u00e9es parce que le tampon est trop petit, statut invalide [{0}]
channel.nio.ssl.wrapException=La n\u00e9gociation a \u00e9chou\u00e9e pendant le wrap
channel.nio.ssl.wrapFail=Impossible d''enrober (wrap) les donn\u00e9es, le status est invalide [{0}]

endpoint.accept.fail=Aucun socket n'a pu \u00eatre accept\u00e9
endpoint.alpn.fail=Erreur de configuration de la terminaison pour ALPN en utilisant [{0}]
endpoint.alpn.negotiated=Le protocole [{0}] a \u00e9t\u00e9 n\u00e9goci\u00e9 en utilisant ALPN
endpoint.apr.applyConf=Application de OpenSSLConfCmd au contexte SSL
endpoint.apr.checkConf=V\u00e9rification de OpenSSLConf en cours
endpoint.apr.errApplyConf=Impossible d'appliquer OpenSSLConf au contexte SSL
endpoint.apr.errCheckConf=Erreur pendant la v\u00e9rification de OpenSSLConf
endpoint.apr.errMakeConf=Impossible de cr\u00e9er le contexte de OpenSSLConf
endpoint.apr.failSslContextMake=Incapable de cr\u00e9er un SSLContext. V\u00e9rifier que SSLEngine est activ\u00e9 dans l'AprLifecycleListener, que l'AprLifecycleListener a \u00e9t\u00e9 correctement initialis\u00e9 et qu'un protocole SSL valide a \u00e9t\u00e9 sp\u00e9cifi\u00e9.
endpoint.apr.invalidSslProtocol=Un valeur invalide [{0}] a \u00e9t\u00e9 donn\u00e9e pour l''attribut SSLProtocol
endpoint.apr.maxConnections.running=La terminaison APR ne permet pas de fixer maxConnections pendant son ex\u00e9cution, la valeur existante [{0}] continuera \u00e0 \u00eatre utilis\u00e9e
endpoint.apr.maxConnections.unlimited=La terminaison APR ne supporte pas un nombre illimit\u00e9 de connections, la valeur existante [{0}] va continuer \u00e0 \u00eatre utilis\u00e9e
endpoint.apr.noSendfileWithSSL=Sendfile n'est pas support\u00e9 avec le connecteur APR lorsque SSL est active
endpoint.apr.pollAddInvalid=Tentative invalide d''ajout d''une socket [{0}] au scrutateur ("poller")
endpoint.apr.pollError=Le scrutateur ("poller") a \u00e9chou\u00e9 avec l''erreur [{0}] : [{1}]
endpoint.apr.pollMergeEvents=Fusion des \u00e9v\u00e8nements [{1}] du poller pour le socket [{0}] pour cr\u00e9er l''\u00e9v\u00e8nement fusionn\u00e9 [{2}]
endpoint.apr.pollUnknownEvent=Un socket a \u00e9t\u00e9 retourn\u00e9 par le poller avec un \u00e9v\u00e8nement inconnu [{0}]
endpoint.apr.remoteport=Le socket APR [{0}] a \u00e9t\u00e9 ouvert avec le port distant [{1}]
endpoint.apr.tooManyCertFiles=Plus de fichiers de certificats ont \u00e9t\u00e9 configur\u00e9s que ce que l'AprEndpoint peut g\u00e9rer
endpoint.debug.channelCloseFail=Echec de la fermeture du canal (channel)
endpoint.debug.destroySocket=Destruction du socket [{0}]
endpoint.debug.pollerAdd=Ajout \u00e0 la addList socket [{0}], inactivit\u00e9 maximale [{1}], drapeaux [{2}]
endpoint.debug.pollerAddDo=Ajout du socket [{0}] au poller
endpoint.debug.pollerProcess=Traitement de(s) \u00e9v\u00e8nement(s) [{1}] pour la socket [{0}]
endpoint.debug.pollerRemove=Essai d''enlever [{0}] du poller
endpoint.debug.pollerRemoved=Enlev\u00e9 [{0}] du poller
endpoint.debug.registerRead=Enregistrement de l\u2019int\u00e9r\u00eat en lecture pour [{0}]
endpoint.debug.registerWrite=Enregistrement de l\u2019int\u00e9r\u00eat en \u00e9criture pour [{0}]
endpoint.debug.socket=socket [{0}]
endpoint.debug.socketCloseFail=Echec de fermeture du socket
endpoint.debug.socketTimeout=Expiration [{0}]
endpoint.debug.unlock.fail=Re\u00e7u une exception en essayant de d\u00e9verrouiller l''accepteur sur le port [{0}]
endpoint.debug.unlock.localFail=Impossible de d\u00e9terminer l''adresse locales pour [{0}]
endpoint.debug.unlock.localNone=Impossible de d\u00e9bloquer l''accepteur pour [{0}] car l''adresse locale n''\u00e9tait pas disponible
endpoint.duplicateSslHostName=Plusieurs \u00e9l\u00e9ments SSLHostConfig ont \u00e9t\u00e9 fournis pour le nom d''h\u00f4te [{0}], les noms d''h\u00f4te doivent \u00eatre uniques
endpoint.err.close=Une exception s'est produite en essayant de fermer le socket
endpoint.err.handshake=Echec de n\u00e9gociation
endpoint.err.unexpected=Erreur inattendue lors du traitement du socket
endpoint.executor.fail=L''ex\u00e9cuteur a rejet\u00e9 le traitement du socket [{0}]
endpoint.getAttribute=[{0}] est [{1}]
endpoint.init.bind=L''association du socket a \u00e9chou\u00e9 : [{0}] [{1}]
endpoint.init.bind.inherited=Pas de canal h\u00e9rit\u00e9 alors que le connecteur \u00e9tait configur\u00e9 pour en utiliser un
endpoint.init.listen=L''\u00e9coute sur le socket a \u00e9chou\u00e9 : [{0}] [{1}]
endpoint.init.notavail=APR n'est pas disponible
endpoint.invalidJmxNameSslHost=Impossible de g\u00e9n\u00e9rer un nom d''objet JMX valide pour le SSLHostConfig associ\u00e9 \u00e0 l''h\u00f4te [{0}]
endpoint.invalidJmxNameSslHostCert=Impossible de g\u00e9n\u00e9rer un nom d''objet JMX valide pour le SSLHostConfigCertificate associ\u00e9 \u00e0 l''h\u00f4te [{0}] et au type de certificat [{1}]
endpoint.jmxRegistrationFailed=Echec de l''enregistrement JMX de l''objet avec le nom [{0}]
endpoint.jsse.noSslContext=Aucun SSLContext n''a \u00e9t\u00e9 trouv\u00e9 pour le nom d''h\u00f4te [{0}]
endpoint.launch.fail=Impossible de d\u00e9marrer le nouvel ex\u00e9cutable
endpoint.nio.registerFail=Echec d'enregistrement du socket avec le s\u00e9lecteur du poller
endpoint.nio.selectorCloseFail=Impossible de fermer le s\u00e9lecteur lors de la fermeture du poller
endpoint.nio.stopLatchAwaitFail=Les pollers ne se sont pas arr\u00eat\u00e9s dans le temps imparti
endpoint.nio.stopLatchAwaitInterrupted=Ce thread a \u00e9t\u00e9 interrompu pendant qu'il attendait l'arr\u00eat des scrutateurs ("pollers")
endpoint.nio.timeoutCme=Exception pendant le traitement du d\u00e9lai d'attente maximum ; le code a \u00e9t\u00e9 v\u00e9rifi\u00e9 de mani\u00e8re r\u00e9p\u00e9t\u00e9e et aucune modification concurrence n'a pu \u00eatre trouv\u00e9e, si vous obtenez cette erreur de mani\u00e8re reproductible merci d'ouvrir un rapport d'erreur sur Tomcat en fournissant les informations pour la reproduire
endpoint.nio2.exclusiveExecutor=Le connecteur NIO2 a besoin d'un acc\u00e8s exclusif \u00e0 un ex\u00e9cuteur pour pouvoir avoir un comportement pr\u00e9visible lors de son arr\u00eat
endpoint.noSslHostConfig=Pas d''\u00e9l\u00e9ment SSLHostConfig trouv\u00e9 avec hostName [{0}] correspondant au defaultSSLHostConfigName du connecteur [{1}]
endpoint.noSslHostName=Aucun nom d'h\u00f4te n'a \u00e9t\u00e9 fourni pour la configuration de l'h\u00f4te SSL
endpoint.poll.error=Erreur inattendue du poller
endpoint.poll.fail=Echec critique du poller, red\u00e9marrage : [{0}] [{1}]
endpoint.poll.initfail=Echec de cr\u00e9ation du poller
endpoint.poll.limitedpollsize=Echec de cr\u00e9ation d''un poller avec la taille sp\u00e9cifi\u00e9e [{0}]
endpoint.process.fail=Erreur lors de l'allocation d'un processeur de socket
endpoint.processing.fail=Erreur lors de l\u2019ex\u00e9cution du processeur du socket
endpoint.removeDefaultSslHostConfig=Le SSLHostConfig par d\u00e9faut (de nom [{0}]) ne peut pas \u00eatre retir\u00e9
endpoint.sendfile.addfail=Echec de Sendfile :  [{0}] [{1}]
endpoint.sendfile.error=Erreur lors de sendfile
endpoint.serverSocket.closeFailed=Le socket serveur [{0}] n''a pas pu \u00eatre ferm\u00e9
endpoint.setAttribute=Met [{0}] \u00e0 [{1}]
endpoint.timeout.err=Erreur en traitant le d\u00e9passement de temps d'attente du socket
endpoint.unknownSslHostName=Le nom d''h\u00f4te SSL [{0}] n''est pas reconnu pour cette terminaison
endpoint.warn.executorShutdown=L''ex\u00e9cuteur associ\u00e9 au pool de threads [{0}] n''est pas compl\u00e8tement arr\u00eat\u00e9, certains threads d''application peuvent toujours \u00eatre en cours d''ex\u00e9cution
endpoint.warn.incorrectConnectionCount=Le d\u00e9compte du nombre de connections est incorrect, la m\u00e9thode de fermeture d'un m\u00eame socket a \u00e9t\u00e9 appel\u00e9e plusieurs fois
endpoint.warn.noLocalAddr=Impossible de d\u00e9terminer l''addresse locale pour le socket [{0}]
endpoint.warn.noLocalName=Incapable de d\u00e9terminer l''h\u00f4te local ("local host") pour la socket [{0}]
endpoint.warn.noLocalPort=Impossible de d\u00e9terminer le port local pour le socket [{0}]
endpoint.warn.noRemoteAddr=Impossible de d\u00e9terminer l''adresse distante pour le socket [{0}]
endpoint.warn.noRemoteHost=Impossible de d\u00e9terminer le nom d''h\u00f4te distant pour le socket [{0}]
endpoint.warn.noRemotePort=Impossible de d\u00e9terminer le port distant pour le socket [{0}]
endpoint.warn.unlockAcceptorFailed=Le thread qui accepte les sockets [{0}] n''a pu \u00eatre d\u00e9bloqu\u00e9, arr\u00eat forc\u00e9 su socket serveur

sniExtractor.clientHelloInvalid=Le message ClientHello n'\u00e9tait pas format\u00e9 correctement
sniExtractor.clientHelloTooBig=Le ClientHello n'a pas \u00e9t\u00e9 pr\u00e9sent\u00e9 dans un seul enregistrement TLS donc l'information SNI n'a pu \u00eatre extraite

socket.apr.clientAbort=Le client a avort\u00e9 la connection
socket.apr.closed=Le socket [{0}] associ\u00e9 avec cete connection a \u00e9t\u00e9 ferm\u00e9.
socket.apr.read.error=Erreur inattendue [{0}] lors de la lecture de donn\u00e9es depuis le socket APR [{1}] avec l''enrobeur [{2}]
socket.apr.write.error=Erreur inattendue [{0}] lors de l''\u00e9criture de donn\u00e9es vers le socket APR [{1}] avec l''enrobeur [{2}]
socket.closed=Le socket associ\u00e9 \u00e0 cette connection a \u00e9t\u00e9 ferm\u00e9
socket.sslreneg=Exception lors de la ren\u00e9gociation de la connection SSL

sslHostConfig.certificate.notype=Plusieurs certificats ont \u00e9t\u00e9 sp\u00e9cifi\u00e9s et au moins un n'a pas d'attribut type
sslHostConfig.certificateVerificationInvalid=La valeur de v\u00e9rification de certificat [{0}] n''est pas reconnue
sslHostConfig.fileNotFound=Le fichier [{0}] configur\u00e9 n''existe pas.
sslHostConfig.invalid_truststore_password=Le mot de passe de la base de confiance n'a pas pu \u00eatre utilis\u00e9 pour d\u00e9verrouiller et ou valider celle ci, nouvel essai en utilisant un mot de passe null pour passer la validation
sslHostConfig.mismatch=La propri\u00e9t\u00e9 [{0}] a \u00e9t\u00e9 fix\u00e9e sur le SSLHostConfig nomm\u00e9 [{1}] et est pour la syntaxe de configuration [{2}] mais le SSLHostConfig est utilis\u00e9 avec la syntaxe de configuration [{3}]
sslHostConfig.opensslconf.alreadyset=Un tentative de fixer une autre OpenSSLConf a \u00e9t\u00e9 ignor\u00e9e
sslHostConfig.opensslconf.null=L'OpenSSLConf nul a \u00e9t\u00e9 ignor\u00e9
sslHostConfig.prefix_missing=Le protocole [{0}] a \u00e9t\u00e9 ajout\u00e9 \u00e0 la liste des protocoles du SSLHostConfig nomm\u00e9 [{1}], v\u00e9rifier qu''un pr\u00e9fixe +/- ne manque pas

sslHostConfigCertificate.mismatch=La propri\u00e9t\u00e9 [{0}] a \u00e9t\u00e9 d\u00e9finie sur le SSLHostConfigCertificate nomm\u00e9 [{1}] et est pour un certificat de stockage de type [{2}] mais le certificat est utilis\u00e9 avec un stockage de type [{3}]

sslImplementation.cnfe=Impossible de cr\u00e9er une SSLImplementation avec la class [{0}]

sslUtilBase.active=Les [{0}] qui sont actifs sont : [{1}]
sslUtilBase.aliasIgnored=Le mode FIPS est activ\u00e9 donc le nom d''alias [{0}] sera ignor\u00e9, s''il il y a plus d''une cl\u00e9 dans la keystore, la cl\u00e9 utilis\u00e9e d\u00e9pendra de son impl\u00e9mentation
sslUtilBase.alias_no_key_entry=Le nom alias [{0}] n''identifie pas une entr\u00e9e de cl\u00e9
sslUtilBase.invalidTrustManagerClassName=Le trustManagerClassName fourni [{0}] n''impl\u00e9mente pas javax.net.ssl.TrustManager
sslUtilBase.keystore_load_failed=Impossible de changer la base de cl\u00e9s de type [{0}] avec le chemin [{1}] \u00e0 cause de [{2}]
sslUtilBase.noCertFile=L'attribut certificateFile de SSLHostConfig doit \u00eatre d\u00e9fini lorsqu'un connecteur SSL est utilis\u00e9
sslUtilBase.noCrlSupport=Le truststoreProvider [{0}] ne supporte pas d''option de configuration certificateRevocationFile
sslUtilBase.noKeys=Aucun alias pour les cl\u00e9s priv\u00e9es n'a \u00e9t\u00e9 trouv\u00e9 dans la base de cl\u00e9s
sslUtilBase.noVerificationDepth=Le truststoreProvider [{0}] ne supporte pas l''option de configuration certificateVerificationDepth
sslUtilBase.noneSupported=Aucun des [{0}] sp\u00e9cifi\u00e9s n''est support\u00e9 par le moteur SSL : [{1}]
sslUtilBase.skipped=Quelques [{0}] sp\u00e9cifi\u00e9s ne sont pas support\u00e9s par le moteur SSL et ont \u00e9t\u00e9 ignor\u00e9s : [{1}]
sslUtilBase.ssl3=SSLv3 a \u00e9t\u00e9 explicitement activ\u00e9.  Ce protocole est connu comme non-s\u00e9curis\u00e9.
sslUtilBase.tls13.auth=L\u2019impl\u00e9mentation JSSE de TLS 1.3 ne supporte pas l'authentification apr\u00e8s la n\u00e9gociation initiale, elle est donc incompatible avec l\u2019authentification optionnelle du client
sslUtilBase.trustedCertNotChecked=Les dates de validit\u00e9 du certificat de confiance dont l''alias est [{0}] n''ont pas \u00e9t\u00e9 v\u00e9rifi\u00e9es car sont type est inconnu
sslUtilBase.trustedCertNotValid=Le certificat de confiance avec l''alias [{0}] et le DN [{1}] n''est pas valide \u00e0 cause de [{2}], les certificats sign\u00e9s par ce certificat de confiance SERONT accept\u00e9s
