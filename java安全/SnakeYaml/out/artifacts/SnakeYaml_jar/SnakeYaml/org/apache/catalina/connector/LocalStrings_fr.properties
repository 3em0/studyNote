# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

coyoteAdapter.accesslogFail=Exception lors d'une tentative d'ajout d'une entr\u00e9e au journal d'acc\u00e8s (access log)
coyoteAdapter.asyncDispatch=Exception lors du traitement d'une requ\u00eate asynchrone
coyoteAdapter.authenticate=L''utilisateur authentifi\u00e9 [{0}] a \u00e9t\u00e9 fourni par le connecteur
coyoteAdapter.authorize=Autorisation de l''utilisateur [{0}] en utilisant le Realm de Tomcat
coyoteAdapter.checkRecycled.request=Trouv\u00e9 une requ\u00eate non recycl\u00e9e dont le recyclage a \u00e9t\u00e9 forc\u00e9
coyoteAdapter.checkRecycled.response=Trouv\u00e9 une r\u00e9ponse non recycl\u00e9e, et forc\u00e9 son recyclage
coyoteAdapter.debug=La variable [{0}] a la valeur [{1}]
coyoteAdapter.nullRequest=Un dispatch asynchrone peut seulement se produire sur une requ\u00eate existante

coyoteConnector.invalidEncoding=L''encodage [{0}] n''est pas reconnu par la JRE. Le connecteur (Connector) continuera \u00e0 utiliser [{1}]
coyoteConnector.invalidPort=Le connecteur ne peut pas d\u00e9marrer, parce que la valeur sp\u00e9cifi\u00e9e du port [{0}] n''est pas valide
coyoteConnector.notAsciiSuperset=L''encodage [{0}] n''inclut pas l''ASCII comme requis par la RFC 7230, le connecteur va continuer \u00e0 utiliser [{1}]
coyoteConnector.parseBodyMethodNoTrace=La m\u00e9thode "TRACE" NE PEUT PAS contenir une entit\u00e9 (voir RFC 2616 Section 9.6)
coyoteConnector.protocolHandlerDestroyFailed=La destruction du gestionnaire de protocole a \u00e9chou\u00e9
coyoteConnector.protocolHandlerInitializationFailed=L'initialisation du gestionnaire de protocole a \u00e9chou\u00e9
coyoteConnector.protocolHandlerInstantiationFailed=L'instantiation du gestionnaire de protocole a \u00e9chou\u00e9
coyoteConnector.protocolHandlerNoAprLibrary=Le protocole configur\u00e9 [{0}] requiert la librairie APR/native qui n''est pas disponible
coyoteConnector.protocolHandlerNoAprListener=Le protocole configur\u00e9 [{0}] requiert AprLifecycleListener qui n''est pas disponible
coyoteConnector.protocolHandlerPauseFailed=La suspension du gestionnaire de protocole a \u00e9chou\u00e9e
coyoteConnector.protocolHandlerResumeFailed=Le red\u00e9marrage du gestionnaire de protocole a \u00e9chou\u00e9
coyoteConnector.protocolHandlerStartFailed=Le d\u00e9marrage du gestionnaire de protocole a \u00e9chou\u00e9
coyoteConnector.protocolHandlerStopFailed=L'arr\u00eat du gestionnaire de protocole a \u00e9chou\u00e9

coyoteInputStream.nbNotready=En mode non-bloquant, vous ne pouvez pas lire du ServletInputStream tant que la lecture pr\u00e9c\u00e9dente n'est pas termin\u00e9e et isReady() renvoie "true"

coyoteOutputStream.nbNotready=En mode non bloquant, vous ne devez pas \u00e9crire sur la ServletOutputStream avant que l'\u00e9criture pr\u00e9c\u00e9dente ne soit termin\u00e9e et que isReady() ne renvoie true

coyoteRequest.alreadyAuthenticated=Cette requ\u00eate a d\u00e9j\u00e0 \u00e9t\u00e9 authentifi\u00e9e
coyoteRequest.attributeEvent=Une exception a \u00e9t\u00e9 lanc\u00e9e par l'instance d'\u00e9coute pour l'\u00e9v\u00e8nement attributs (attributes)
coyoteRequest.authenticate.ise=Impossible d'appeler authenticate() apr\u00e8s le d\u00e9but de l'envoi de la r\u00e9ponse
coyoteRequest.changeSessionId=Impossible de changer l'id de la session, il n'y a pas de session associ\u00e9e \u00e0 cette requ\u00eate
coyoteRequest.chunkedPostTooLarge=Les param\u00e8tres n'ont pas \u00e9t\u00e9 trait\u00e9s parce que la taille des donn\u00e9es du POST \u00e9taient trop grandes ; comme cette requ\u00eate utilisait le d\u00e9coupage par morceaux (chunking), le traitement est arr\u00eat\u00e9 ; utiliser l'attribut maxPostSize du connecteur pour r\u00e9soudre ce probl\u00e8me si l'application devrait accepter des tailles de POST plus importantes
coyoteRequest.filterAsyncSupportUnknown=Incapacit\u00e9 de d\u00e9terminer si un des filtres ne supporte pas le mode asynchrone
coyoteRequest.getContextPath.ise=Impossible de trouver une correspondance entre le chemin canonique du contexte [{0}] et l''URI envoy\u00e9e par l''agent de l''utilisateur [{1}]
coyoteRequest.getInputStream.ise="getReader()" a d\u00e9j\u00e0 \u00e9t\u00e9 appel\u00e9 pour cette requ\u00eate
coyoteRequest.getReader.ise="getInputStream()" a d\u00e9j\u00e0 \u00e9t\u00e9 appel\u00e9 pour cette requ\u00eate
coyoteRequest.gssLifetimeFail=Echec d''obtention de la dur\u00e9e de vie restante pour le "user principal" [{0}]
coyoteRequest.maxPostSizeExceeded=La requ\u00eate multi part contenait des donn\u00e9es de param\u00e8tres (en excluant les fichiers envoy\u00e9s) dont la taille a exc\u00e9d\u00e9 la limite maxPostSize fix\u00e9e sur le connecteur associ\u00e9
coyoteRequest.noAsync=Impossible de d\u00e9marrer le mode asynchrone car les classes [{0}] de la cha\u00eene de traitement ne le supportent pas
coyoteRequest.noMultipartConfig=Impossible de traiter des parties, parce qu'aucune configuration multi-parties n'a \u00e9t\u00e9 fournie
coyoteRequest.parseParameters=Exception lors du traitement des param\u00e8tres envoy\u00e9s par POST
coyoteRequest.postTooLarge=Les param\u00e8tres n'ont pas \u00e9t\u00e9 \u00e9valu\u00e9s car la taille des donn\u00e9es post\u00e9es est trop important. Utilisez l'attribut maxPostSize du connecteur pour corriger ce probl\u00e8me si votre application doit accepter des POSTs importants.
coyoteRequest.sendfileNotCanonical=Impossible d''obtenir le nom canonique du fichier [{0}] qui a \u00e9t\u00e9 donn\u00e9 pour le sendfile
coyoteRequest.sessionCreateCommitted=Impossible de cr\u00e9er une session apr\u00e8s que la r\u00e9ponse ait \u00e9t\u00e9 envoy\u00e9e
coyoteRequest.sessionEndAccessFail=Exception lanc\u00e9e durant l'arr\u00eat de l'acc\u00e8s \u00e0 la session durant le recyclage de la requ\u00eate
coyoteRequest.setAttribute.namenull=Impossible d'appeler "setAttribute" avec un nom nul
coyoteRequest.uploadCreate=Un r\u00e9pertoire temporaire [{0}] pour les fichiers envoy\u00e9s sera cr\u00e9e car il est requis par le Servlet [{1}]
coyoteRequest.uploadCreateFail=Echec de cr\u00e9ation du r\u00e9pertoire [{0}] pour les fichiers envoy\u00e9s
coyoteRequest.uploadLocationInvalid=Le r\u00e9pertoire temporaire [{0}] pour les envois de fichier est invalide

coyoteResponse.encoding.invalid=L''encodage [{0}] n''est pas reconnu par le JRE
coyoteResponse.getOutputStream.ise="getWriter()" a d\u00e9j\u00e0 \u00e9t\u00e9 appel\u00e9 pour cette r\u00e9ponse
coyoteResponse.getWriter.ise="getOutputStream()" a d\u00e9j\u00e0 \u00e9t\u00e9 appel\u00e9 pour cette r\u00e9ponse
coyoteResponse.reset.ise=Impossible d'appeler reset() apr\u00e8s le d\u00e9but de l'envoi de la r\u00e9ponse
coyoteResponse.resetBuffer.ise=Impossible de remettre \u00e0 z\u00e9ro le tampon apr\u00e8s que la r\u00e9ponse ait \u00e9t\u00e9 envoy\u00e9e
coyoteResponse.sendError.ise=Impossible d'appeler "sendError()" apr\u00e8s que la r\u00e9ponse ait \u00e9t\u00e9 envoy\u00e9e
coyoteResponse.sendRedirect.ise=Impossible d'appeler "sendRedirect()" apr\u00e8s que la r\u00e9ponse ait \u00e9t\u00e9 envoy\u00e9e
coyoteResponse.sendRedirect.note=<html><body><p>Redirection vers <a href="{0}">{0}</a></p></body></html>
coyoteResponse.setBufferSize.ise=Impossible de changer la taille du tampon apr\u00e8s que les donn\u00e9es aient \u00e9t\u00e9 \u00e9crites

inputBuffer.requiresNonBlocking=Pas disponible en mode non bloquant
inputBuffer.streamClosed=Le flux a \u00e9t\u00e9 ferm\u00e9

outputBuffer.writeNull=L'argument String dans write(String, int, int) ne doit pas \u00eatre null

request.asyncNotSupported=Un filtre ou un Servlet de la cha\u00eene actuelle ne supporte pas le mode asynchrone
request.fragmentInDispatchPath=Le fragment dans le chemin de dispatch [{0}] a \u00e9t\u00e9 enlev\u00e9
request.illegalWrap=L'enrobeur de la r\u00e9ponse doit enrober la requ\u00eate obtenue \u00e0 partir de getRequest()
request.notAsync=Il est interdit d'appeler cette m\u00e9thode si la requ\u00eate actuelle n'est pas en mode asynchrone (isAsyncStarted() a renvoy\u00e9 false)
request.session.failed=Erreur de chargement de la session [{0}] \u00e0 cause de [{1}]

requestFacade.nullRequest=L'objet requ\u00eate a \u00e9t\u00e9 recycl\u00e9 et n'est plus associ\u00e9 \u00e0 cette fa\u00e7ade

response.illegalWrap=L'enrobeur de la r\u00e9ponse doit enrober la r\u00e9ponse obtenue \u00e0 partir de getResponse()
response.sendRedirectFail=Impossible d''envoyer une redirection vers [{0}]

responseFacade.nullResponse=L'objet r\u00e9ponse a \u00e9t\u00e9 recycl\u00e9 et n'est plus associ\u00e9 \u00e0 cette fa\u00e7ade
