# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

beanNameELResolver.beanReadOnly=Le nom de bean [{0}] est en lecture seule

elProcessor.defineFunctionInvalidClass=La classe [{0}] n''est pas publique
elProcessor.defineFunctionInvalidMethod=La m\u00e9thode [{0}] sur la classe [{1}] n''est pas une m\u00e9thode statique publique
elProcessor.defineFunctionInvalidParameterList=La liste de param\u00e8tres [{0}] pour la m\u00e9thode [{1}] de la classe [{2}] n''est pas valide
elProcessor.defineFunctionInvalidParameterTypeName=Le type [{0}] du param\u00e8tre de la m\u00e9thode [{1}] sur la classe [{2}] n''est pas valide
elProcessor.defineFunctionNoMethod=Une m\u00e9thode statique et publique [{0}] n''a pas pu \u00eatre trouv\u00e9e sur la classe [{1}]
elProcessor.defineFunctionNullParams=On ou plusieurs param\u00e8tres d'entr\u00e9e sont null

expressionFactory.cannotCreate=Impossible de cr\u00e9er une ExpressionFactory de type [{0}]
expressionFactory.cannotFind=Impossible de trouver une ExpressionFactory de type [{0}]
expressionFactory.readFailed=Impossible de lire [{0}]

importHandler.ambiguousImport=La classe [{0}] n''a pas pu \u00eatre import\u00e9e car elle entre en conflit avec [{1}] qui a d\u00e9j\u00e0 \u00e9t\u00e9 import\u00e9e
importHandler.ambiguousStaticImport=L''import statique [{0}] ne peut pas \u00eatre trait\u00e9 parce qu''il est en conflit avec [{1}] qui a d\u00e9j\u00e0 \u00e9t\u00e9 import\u00e9
importHandler.classNotFound=La classe [{0}] n''a pu \u00eatre import\u00e9e, vu qu''on ne l''a pas trouv\u00e9e
importHandler.invalidClass=La classe [{0}] doit \u00eatre publique, non abstraite, ne pas \u00eatre une interface et (pour Java 9+) \u00eatre dans un package export\u00e9
importHandler.invalidClassName=Le nom de la classe \u00e0 importer [{0}] doit comprendre un paquet
importHandler.invalidClassNameForStatic=La classe [{0}] sp\u00e9cifi\u00e9e pour l''import statique [{1}] n''est pas valide
importHandler.invalidStaticName=Le nom de la m\u00e9thode statique ou champ \u00e0 importer [{0}] doit inclure une calsse
importHandler.staticNotFound=L''importation statique [{0}] n''a pas \u00e9t\u00e9 trouv\u00e9e dans la classe [{1}] pour [{2}]

lambdaExpression.tooFewArgs=Seuls [{0}] arguments ont \u00e9t\u00e9 fournis pour une expression lambda qui en demande au moins [{1}]

objectNotAssignable=Impossible d''ajouter un objet du type [{0}] \u00e0 un tableau d''objets de type [{1}]
propertyNotFound=La propri\u00e9t\u00e9 [{1}] n''a pas \u00e9t\u00e9 trouv\u00e9e sur le type [{0}]
propertyNotReadable=La propri\u00e9t\u00e9 [{1}] n''est pas lisible sur le type [{0}]
propertyNotWritable=La propri\u00e9t\u00e9 [{1}] ne peut pas \u00eatre \u00e9crite pour le type [{0}]
propertyReadError=Erreur lors de la lecture de [{1}] sur le type [{0}]
propertyWriteError=Erreur d''\u00e9criture [{1}] sur le type [{0}]

staticFieldELResolver.methodNotFound=Aucune m\u00e9thode publique et statique nomm\u00e9e [{0}] n''a \u00e9t\u00e9 trouv\u00e9e dans la classe [{1}]
staticFieldELResolver.notFound=Aucun champ public statique nomm\u00e9 [{0}] n''a \u00e9t\u00e9 trouv\u00e9 dans la classe [{1}] (export\u00e9e pour Java 9+)
staticFieldELResolver.notWriteable=L''\u00e9criture dans les champs statiques (champ [{0}] dans la classe [{1}] dans le cas pr\u00e9sent) est interdite

util.method.ambiguous=Impossible de trouver une m\u00e9thode non ambigu\u00eb : {0}.{1}({2})
util.method.notfound=M\u00e9thode non trouv\u00e9e : {0}.{1}({2})
